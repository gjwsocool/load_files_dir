### 进程环境

#### 程序和进程的区别

程序

> 存放在硬盘上的、**静态的**机器指令文件-------静态就是没有运行的意思

进程

> 将硬盘上的程序代码拷贝到`内存`中，正在被cpu执行的程序
>
> > 运行的程序：cpu从第一条指令开始，一条一条的执行程序中的所有指令代码

#### 进程所需的运行环境

> 启动代码、环境变量、c程序的内存空间布局、库等

1. 启动代码

   >`就是启动程序的代码`，其实所有高级语言编写的程序，都有启动代码
   >
   >> c程序都是从main函数开始运行的,其实main也是需要被`C程序的启动代码`调用的

2. 环境变量

   > 进程*在运行的过程中*需要用到环境变量，而环境变量存放在了环境表中，也就是`环境变量表`。

3. c程序的内存空间结构

   >+ c程序运行时，是运行在`内存`上的
   >
   >+ 需要在`内存上开辟出一块空间`给c程序，然后将C代码会被`从硬盘拷贝到内存空间`上运行
   >
   >+ 这段空间必须布局为`c程序运行所需`的空间结构，c程序才能运行
   >
   >  > 所以，c**程序的内存空间结构**也是必须要的“进程环境”

   ​        **<font color=red>比如程序在调用函数时需要用到“栈”这个东西，那么就必须在内存空间中构建出“栈”,也就是说以栈的形式去管理这块内存空间</font>**

   > 内存空间是需要布局的，比如那些内存是代码区，哪些内存是数据区

4. 库

   > > 库是也是非常重要的进程环境
   >
   > c程序（进程）运行时，都是需要库的支持的
   >
   > > 没有库的支持，程序基本做不了太过复杂的事

#### 理解进程环境后回答如下问题

与进程环境相关的API

+ main函数是被谁调用的
+ main函数的返回值返回给了谁
+ main函数的参数有什么用
+ 什么是进程的环境变量表
+ 什么是程序的内存空间，程序的内存空间为什么要进行结构的布局

---

### 启动代码

> 所有高级语言的程序，都有自己的启动代码

C程序运行时，最开始运行的是启动代码，启动代码再去调用main函数，然后整个C程序都已运行

```
                          .......
						     |
							 |
						   子函数2
							 |
							 |
				           子函数1  
							 |
							 |
						  main函数
							 | 
							 |
						  启动代码
```

高级语言程序 = 启动代码 + 自己代码

#### 启动代码由谁提供

启动代码一般（99%）都是由`编译器`提供的

> 一般有两种提供方式
>
> 1. 源码形式
>
>    > 以源码形式提供时，`编译器`会将启`动代码的源文件`和`自己程序的源文件`一起编译
>    >
>    > + 像开发`单片机`这种没有OS的计算机的C程序时，启动代码一般是源码形式提供的
>    >
>    > ```
>    > 				       	编译
>    >           启动代码.c  ——————————> ***.o   
>    >                                         \
>    > 										 \
>    > 										  \  链接
>    > 											 ————>  可执行文件（可执行程序）
>    >                                             /
>    > 			            编译  			  /
>    >   我的程序 ***.c ...  ——————————> ***.o ... / 
>    > ```
>
> 2. 二级制的.o（目标文件）形式
>
>    > 直接以.o形式提供时，省去了我自己对“启动代码”的编译
>    >
>    > ```
>    >                              启动代码
>    >                           ***.o ***.o   
>    >                                    \
>    > 									\
>    > 					                 \  链接
>    > 									   ————>  可执行文件（可执行程序）
>    > 									  /
>    > 					 编译             /
>    > 	我的程序 ***.c... ————> ***.o .../
>    > ```
>    >
>    > 一般来说，如果开发的程序是`运行在OS上`时，那么编译器一般是以`.o`形式来提供启动代码

>gcc就是以.o形式提供的，基于OS运行的程序的启动代码
>
>gcc时加一个`-v`选项，查看gcc编译链接的详细情况时，可以看到有很多.o，这些.o就是gcc提供的启动代码

+ gcc -v 文件名.c
+ <img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106175949652.png" alt="image-20221106175949652" style="zoom:50%;" />

+ 在编译的详细信息里面，有很多的事先就被编译好的.o文件，这些.o文件就是用来生成启动代码的

#### 启动代码做了什么

启动代码基本由`汇编语言`编写

启动代码做了两件重要的事：

1. 对c程序的内存空间进行布局，得到c程序运行所需要的内存空间结构

   > 函数调用需要“栈”，启动代码就需要在c内存空间上建立“栈”
   >
   > > 从c内存空间中划出一段空间，然后以“栈”的形式来进行管理
   >
   > + uboot的最开始的汇编代码就是启动代码，其中`有一段汇编代码就是用来建立栈空间`

2. 留下相应库接口,方便与库进行链接

   > 裸机只能调用静态库，但是有os时候，大部分用动态库

##### 为什么启动代码基本用汇编语言来写

​        在程序的`内存空间结构`还没有布局起来之前，高级语言程序还无法运行，此时只能`使用汇编`，当利用汇编编写的启动代码将高级语言的内存空间结构建立起来后，自然就可以运行c/c++等高级语言的程序了。

> 比如C语言无法用C语言去写启动代码，比如C语言函数调用需要栈，但是启动代码需要布局栈结构。
>
> > ​        如果程序使用的是`动态库`的话，编译时，动态库代码并不会被直接编译到程序中，只会`留下相应的接口`，程序运行起来后，才会去`对接库代码`，为了能够`对接动态库`，启动代码会留下动态库的对接接口。



### 裸机上程序是怎么运行起来的

分为裸机和操作系统两种情况：

1. 裸机的情况

   > 裸机，就是没有OS

   1. 内存和硬盘一体式

      51单片机-----没有单独的内存和单独硬盘，使用的是内存和硬盘功能二合一的norflash

      > norflash既是内存也是硬盘
      >
      > + 因为norflash的`访问速度很快`，因此cpu能够直接从norflash上读取指令并执行，此时norflash就是一个内存
      > + 因为norflash能够`永久保存数据`，设备关电后，数据依然存在，所以将程序下载到norflash后，关机重上电，程序依然还能运行
      >
      > <img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106201718502.png" alt="image-20221106201718502" style="zoom:50%;" />

   2. 内存和硬盘分开式

> 为什么传统的计算机，硬盘和内存都是分开的?
>
> + 像单片机这种内存和硬盘二合一的norflash形式，由于造价太高，只适合于单片机这种小容量的设备使用
>
> + 1）传统的内存：cpu能够快速访问，但是掉电丢失数据
>   2）传统的硬盘：可以容量做的很大，掉电不丢失数据，但是访问速度很慢
>
>   所以二者相互配合使用，同样能起到与norflash一样的二合一的效果，而且容量更高，单位造价更低
>
> > 像内存和硬盘分开的这种情况，一般都要运行OS的，很少直接以裸机方式来来使用

#### 裸机而且内存和硬盘分开运行程序的方式

1. 直接将下载到`内存`中，然后运行
   + 直接将pc上编译好的代码下载到内存
   + 但是如果断电了，那么内存的数据就丢失了
2. 先下载硬盘永久保存，开机时自动从硬盘中将代码拷贝到内存上，然后运行
   + 将pc上编译好的程序下载到开发板硬盘上后，程序会被永久的保存起来
   + 开机运行时，将硬盘上的代码拷贝到内存上（拷贝的过程通过代码实现）
   + pc指向内存中程序第一条指令，然后整个程序就运行起来了

### 有OS时候程序的运行

有OS的计算机，基本都是内存和硬盘分开式的情况

原因：计算机资源相对丰富，有能力跑OS，如果不上系统直接裸机使用的话，这其实是在浪费计算机资源

> OS也是一个程序，而且是一个很大的裸机程序,因为操作系统直接运行在硬件上

+ OS的代码也是被永久的存放在了硬盘上，开机上电后，启动程序开始启动OS
+ 启动时会将OS代码从硬盘拷贝到内存上，然后就运行起来了

<font color=red>重点：介绍基于OS运行的应用程序，是怎么在OS的支持下运行起来的</font>

> 有操作系统时，启动程序：
>
> ​       启动后OS调用加载器exec函数，这个加载器加载程序，然后会将硬盘上的代码自动拷贝到内存上,`加载的过程就是拷贝的过程，但是只会拷贝当前运行的代码而不是全部的代码`，然后让PC指向第一条指令，cpu取指令执行，那么整个程序就运行起来了。

### 进程的终止方式

> 进程终止方式有两种，一种是正常终止，另一种是异常终止
>
> > 进程主动调用终止函数/返回关键字所实现的结束，就是正常终止
> >
> > + `main调用return`关键字结束
> > + 程序任何位置调用`exit函数`结束
> > + 程序任何位置调用`_exit函数`结束

1.  main函数调用return关键字，实现正常终止

   + return关键字的作用是返回上一级函数

   + > 1. 如果main函数的子函数调用return的话，返回的上一级是main函数
     >
     > 2. 如果main函数调用return的话，main函数所返回的上一级是启动代码

     main函数调用return有两种方式:

     1. 显式调用(return 返回值)

        返回值的意义

        + 返回值标记的了进程的终止状态
        + return 0：正常结束
          return -1：代表了某种操作失败
          return -2：代表了另一种的操作失败
        + 使用：echo $? 查看返回值

<img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106211822886.png" alt="image-20221106211822886" style="zoom:50%;" />

> 如果main函数没有调用任何子函数，而且return又没有返回任何值的话，默认返回-1

2. 隐式调用
   + 不明写出return，当main函数中的最后一句代码执行完毕后，会默认的调用return返回
   + 不过隐式return时，默认返回0。

#### exit函数

> 在程序中任何位置调用exit都有效
>
> > 不管是在main函数中调用，还是在main的子函数中调用，甚至是在子函数的子函数中调用都是有效的
>
> 其实，**main函数调用return返回到启动代码后，启动代码也是调用exit函数来实现正常终止的**

```c
#include <stdlib.h>
//这个参数就是返回值（进程终止状态）
void exit(int status);
```

<img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106213018752.png" alt="image-20221106213018752" style="zoom:50%;" />

一般使用该函数进行`报错处理`

#### _exit()

> _exit是一个系统函数（系统API），而exit是c库函数
>
> > + exit就是调用_exit来实现的
> > + exit对_exit封装后，exit额外还做了好些事情

```c
#include <unistd.h>
void _exit(int status);
```

裸机时:

+ 只能调用return返回，因为没有OS时，不支持exit和_exit函数
+ main的return到启动代码后，返回动作到启动代码就截止了

```
1：      main函数            启动代码          
		return(0)  ——————>  exit(0)  ————————> _exit(0) ————> Linux OS
2：		 exit		 
		 exit(0)  ————————> _exit(0) ————————> Linux OS
3：		_exit
		_exit(0) ————————>Linux OS
----------有OS时，不管是采用哪种方式实现正常终止，返回值都会被返回给OS
```

#### 异常终止

​       进程不是因为`return、exit和_exit函数`而终止的，而是被强行发送了一个`信号`，这个**信号将进程给无条件终止了**，这就是异常终止

1. 自杀---自己调用abort函数，自己给自己发一个`SIGABRT信号`将自己杀死，杀人凶器是信号

2. 他杀---由别人发一个信号，将其杀死，杀人凶器也是信号

   > 程序死循环---ctrl+c结束进程
   >
   > > 其实向终端输入ctrl+c时，就是在向我的进程发送某个信号，然后这个信号将我的程序给异常终止

```c
#include <stdlib.h>
void abort(void);
```

<img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106214557105.png" alt="image-20221106214557105" style="zoom:67%;" />

---

### atexit()

```c
#include <stdlib.h>
//进程终止处理函数
//参数就是被登记“进程终止函数”的地址
/*
当进程无论什么时候正常终止时，会自动的去调用登记的进程终止处理函数，实现进程终止时的一些扫尾处理
------强调的是正常终止，不是异常终止
*/
//返回值 
//函数调用成功返回0，失败返回非零值，不会进行错误号设置。
int atexit(void (*function)(void));
//function为void (*)(void)的函数指针类型
```

<img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106220541678.png" alt="image-20221106220541678" style="zoom:50%;" />

> 在第三手册查到了，说明是个库函数

```c
#include<stdio.h>
#include<stdlib.h>
void process_deal(void){
    printf("deal process!!\n");
}
int main(){
    atexit(process_deal);
    printf("having used function()\n");
    return 0;
}
/*执行结果：
having used function()
deal process!!
*/
```

```c
#include<stdio.h>
#include<stdlib.h>
void process_deal1(void){
    printf("deal1 process!!\n");
}
void process_deal2(void){
    printf("deal2 process!!\n");
}
int main(){
    atexit(process_deal1);
    atexit(process_deal2);
    printf("having used function()\n");
    return 0;
}
/*执行结果：
having used function()
deal2 process!!
deal1 process!!
*/
```

> ​       调用atexit注册时，会将“进程终止处理函数”的函数地址`压入进程栈`中，当进程正常终止时，又会自动从栈中取出函数地址，并执行这个函数，实现进程的扫尾操作。
>
> + 调用顺序刚好和注册顺序相反
> + 在Linux下，调用atexit最多可以允许登记32个终止处理函数
> + 同一个函数如果被登记多次，自然也会被调用多次
>
> > + 只有使用return和exit来正常终止时，才会调用
> > + 异常终止和_exit不会调用该进程终止处理函数

##### 该函数的意义

有时候需要在`进程正常终止`时，做一些`扫尾`操作

+ 不管什么位置或者什么时候做正常终止，该函数都会做扫尾工作，一般在main之前使用

> 比如将链表数据保存到文件中
>
> > 如果不使用进程终止处理函数的话，这个操作有点困难
> >
> > + 因为进程有时候可能是因为某个函数调用失败，然后在函数出错处理时调用exit(-1)终止的，但是你又无法预估哪一个函数会出错，并在出错时调用相应的函数实现链表数据的保存.
> > + 这个时候就可以注册进程终止处理函数来实现了，因为进程终止时，会自动的调用终止处理函数来实现进程的扫尾处理--------将链表数据保存到文件中

<img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221106222632629.png" alt="image-20221106222632629" style="zoom:50%;" />

### 有OS时，进程从启动到正常终止的全过程

>  <img src="/home/guojiawei/.config/Typora/typora-user-images/image-20221107122426700.png" alt="image-20221107122426700" style="zoom: 50%;" />
>
> + exit():加载器
>
> + 启动代码也是调用exit()来终止函数
>
> + 终止处理函数是exit()退出时，优先调用的，等终止处理函数结束时，调用_exit()
>
> > _exit正常退出时，不会调用进程终止处理函数

> 有关标准IO的库缓存的缓冲有三种，`无缓冲`、`行缓冲`、`全缓冲`
>
> > 就是调用文件IO的情况：
> >
> > + 无缓冲就是一调用就输出；行缓冲是满了一行才输出；全缓冲是全部缓冲区积满才输出
>
> > 标准IO是基于系统函数文件IO的封装库
>
> >为什么调用exit正常终止时，会刷新标准io的缓存呢？			
> >
> >	因为exit会调用fclose关闭所有的标准io，关闭时会自动调用fflush来刷新数据。

### 命令行参数

在命令行执行c程序时，可以输入`命令行参数`并传递给`main函数的形参`，然后进程就得到了命令行的参数。

> 其中./可执行文件是命令行参数，其后跟的参数叫程序参数，也是命令行参数

> ```c
> #include<stdio.h>
> int main(int argc,char** argv){
>     int i=0;
>     for(;i<argc;i++){//argc:参数个数
>         printf("%s\t",argv[i]);
>     }
>     printf("\n");
>     int j=0;
>     for(;argv[j]!=NULL;j++){//argv:二级指针，每一级指向一个数组
>         printf("%s\t",argv[j]);
>     }
>     return 0;
> }
> ```
>
> ```c
> //执行结果
> ./main aaa bbb ccc
> ./main  aaa     bbb     ccc   
> ./main  aaa     bbb     ccc    
> ```

#### 命令行参数传递给main函数过程

```
						构建指针数组                  exec
./a.out *** *** ——————> 终端窗口进程 ——————> OS 内核 ——————> 启动代码 ——————> main函数形参
```

### 环境变量表

1. windows
   + 在windows下，如果你不加路径的话，会道默认到当前路径下找程序，没有的话就找不到你的程序
   + 只要把程序所在路径，加入windows的`path环境变量`，加入后，随便在什么位置，都可以不加路径的执行这个程序

> path这个环境变量的作用:专门记录各种`可执行程序`所在路径    
>
> > path记录后:
> >
> > 1）如果你有明确指定路径，那就直接到你指定的路径下找到程序并执行
> >
> > 2）如果没有明确指定路径，首先，在当前目录下找，如果不到这个程序，就会跑到path记录的各个路径下面去找
>
> > ​       通过图形界面，双击快捷图标来打开程序的话，快捷图标可以自动找到所指向的程序并执行，所以对于图形界面这种操作方式来说，path的意义不是很大

#### windows环境变量

1. 环境变量的组成：`环境变量 = 环境变量名 + 环境变量数据`

> 自己创建一个环境变量：
>
> 先在用户变量新建一个：环境变量名+值（一般是路径）
>
> ***`%环境变量名%`***代表的就是该“环境变量”的数据，**%%**就是用来获取环境变量数据（值）

<font color=red>环境变量被存放在了“环境变量表”里面,最原始的“环境变量表”都被保存在了“环境变量文件”中</font>

##### 什么是环境变量

​        其实就是进程在运行时，会用到的`一些字符串信息`，环境表就好比是工具箱，里面放了各种进程运行时需要用到的“工具”，比如各种的路径

> 通过图形界面设置、修改windows“环境变量”时，修改、设置的内容，都会被永久保存到“环境变量文件”中

	每个进程的环境变量表:
	每一个进程都在自己的内存空间（堆空间）保存了一份自己的环境变量表。

> 如果某环境变量的数据有很多条，在环境变量`表`中
>
> + 在windows这边使用;分隔
> + Linux这边则使用:分隔

+ 在命令行执行自己的程序时，查找的是“命令行窗口进程”的“环境变量表”

+ 为什么只有重新打开“命令行窗口”后， 新设置的“环境变量”才生效？

  		因为新设置的环境变量，只是被保存到了windows的环境变量文件中，但是之前所打开的“命令行窗口”进程的“环境变量表”还没有得到更新，只有当重新打开后，才能更新。
  		其实在w10以前更麻烦，更新了环境变量文件后，必须要重启系统才能生效，不过w10后不用这么麻烦了，只需要重新打开即可。

----

### Linux系统变量

#### 永久修改

> 基本都是通过修改“环境变量文件”来实现的

#### 临时修改

> + 就是只修改`当前进程自己`的“环境变量表”
>
> + 其它不相关进程的“环境变量表”以及“环境变量文件”中数据，不会发生任何变化
>
> + 当进程结束时，当前进程的“环境变量表”就被释放了
>
>   ---------这就是临时修改

**如何实现临时修改**

1. 使用`命令`修改------改的是“命令行窗口进程”的环境变量表
2. 通过`API`修改------修改的只是我自己程序的“环境变量表”

>查看所有环境变量
>
>+ Linux
>
>  命令：export
>
>  把当前“终端窗口进程”的所有环境变量全部显示出来
>
>+ windows
>
>   命令：set
>
>  把当前“终端窗口进程”的所有环境变量全部显示出来

>显示单个的环境变量
>
>+ Linux
>
>​       用法：echo $环境变量命令
>
>> PATH是环境变量名，`$PATH`代表的就是PATH的环境变量数据，可以认为$就是用来获取环境变量数据的
>
>在Linux，环境变量的多个数据之间使用:分隔
>
>+ windows
>
>​      用法：set 环境变量名   或者   set %环境变量名%

#### 添加一个新的环境变量

1. Linux

   >例子：`export` AA`=`wwwwwwwwwwww
   >
   >+ 新环境变量名叫AA
   >+ 环境数据为wwwwwwwwwwww
   >
   >在Linux下，环境变量名往往喜欢一律大写

2. windows

> 例子：set aa=wwwwwwwwwwww

#### 修改已有的环境变量

1. 覆盖修改

   > ​        覆盖原有数据，还是使用添加新环境变量的命令来操作，如果添加的“环境变量”之前就存在了，现在的数据会修改原来的数据
   >
   > >  Linux
   > > 			export AA=sssssssssss

2. 末尾追加

   > 保留原有数据
   >
   > 1. windows
   >
   > > + set aa=%AA%;dddddddddddd
   > > + set aa=dddddddddddd;%AA%
   >
   > 2. Linux	
   >
   > > 添加后只用：可执行文件名即可执行，无需./											
   >
   > 	export AA=$AA:dddddddddddd														或者										
   > 	export AA=dddddddddddd:$AA
   > 	//$AA就表示原来的数据，新写的数据用：分割

#### 删除环境变量

1.Linux                         `unset AA`

2.windows 		           `set aa=`

> ​       不管是在windows下还是在Linux下，在命令行下添加/修改环境变量时，改动的只是当前“命令行窗口进程”的环境变量表
>
> > + 当你在另一个窗口查看时，根本找不到这个修改
> >
> > + 当你把当前窗口关闭后，当前“命令行窗口进程”的环境变量表也就被释放了，那么之前的修改自然也就无效了

### 通过API修改环境变量表

1.  **获取环境表中的所有环境变量**

   `environ全局变量`

   + char ******  environ
   + 指向的是一个**字符串指针数组**------------每一行就是环境变量字符串

```c
#include<stdio.h>
#include<stdlib.h>
//声明变量：environ
extern char** environ;
int main(int argc,char** argv){
    int i=0;
    for(;environ[i]!=NULL;i++)
         printf("%s\n",environ[i]);
    return 0;
}
```

```c
//main函数的第三个参数
#include<stdio.h>
#include<stdlib.h>
int main(int argc,char** argv,char** environ){
    int i=0;
    for(;environ[i]!=NULL;i++)
         printf("%s\n",environ[i]);
    return 0;
}
```

2. **调用API：实现环境变量的添加、修改等**

#### putenv、setenv：添加和修改环境变量

```c
#include <stdlib.h>
/*
设置新的环境变量到环境表中:
     如果这环境变量之前就存在，那么这一次的数据会无条件覆盖之前的数据
     如果不存在，就添加这个新的环境变量
*/
//string：新的环境变量，比如“name=value”
int putenv(char *string);
/*
	name：环境变量的名字。
	value：环境变量值。
	overwrite：如果发现name环境变量以前就已经存在，会根据overwrite的值来决定是否覆盖，
				0：不覆盖;0：覆盖
*/
int setenv(const char *name, const char *value, int overwrite);
//tenv函数：调用成功返回0，失败返回非0，errno被设置。
//tenv函数：调用成功返回0，失败返回-1，errno被设置
```

```c
#include<stdio.h>
#include<stdlib.h>
extern char** environ;
int main(int argc,char** argv){
    int i=0;
    putenv("aaa=wwwwwww");
    setenv("bbb","nnnnnnnn",0);
    for(;environ[i]!=NULL;i++)
        printf("%s\n",environ[i]);
    return 0;
}
```

![image-20221107181828223](/home/guojiawei/.config/Typora/typora-user-images/image-20221107181828223.png)

> 注意想查看到结果，不可以采用第三个参数，只可以使用extern声明

#### unsetenv

```c
#include <stdlib.h>
//删除环境变量函数
//删除name指定名字的环境变量
int unsetenv(const char *name);
```

```c
#include<stdio.h>
#include<stdlib.h>
extern char** environ;
int main(int argc,char** argv){
    int i=0;
    putenv("aaa=wwwwwww");
    putenv("aaa=www");
    setenv("bbb","nnnnnnnn",0);
    unsetenv("bbb");
    for(;environ[i]!=NULL;i++)
        printf("%s\n",environ[i]);
    return 0;
}
```

#### getenv

```c
#include <stdlib.h>

char *getenv(const char *name);
```

```c
int main(int argc,char** argv){
    char* p=getenv("PATH");
    printf("PATH=%s\n",p);
    return 0;
}
```

#### 自己所写程序的环境表是怎么来的

> 命令行窗口执行./a.out，那么a.out进程就属于“命令行窗口进程”的子进程，子进程的环境表是从父进程复制得到的
>
> + 当有OS支持时，基本所有的进程都是由父进程“生”出来的
>
> ```
> 	原始进程————>进程————————>进程————————>终端进程——————>a.out进程
> 				|            |             |
> 				|            |             |
> 				V            V             |
> 			   进程		   进程          进程
> 				|            |             |
> 				|			 |             |
> 			   ...		    ...           ...
> ```
>
> + 所有进程的“环境变量表”都是从父进程复制得到的
> + 最原始进程的“环境变量表”则是从“环境变量文件”中读到的
>
> ```
>   原始进程           子进程	         子进程			 子进程			
>  环境变量文件 ————> 进程环境表 ————————>进程环境表 ————————>进程环境表 ————————>.....
> ```
>
> + 自己的进程有一个子进程的话，也会继承自己进程的环境表



###  c程序空间布局		

1. 什么是c程序的内存空间

   > c程序运行时，是运行在`内存`上的，也就是说需要在内存上开辟出一块空间给c程序，然后将C代码会被从硬盘拷贝到内存空间上运行

2. c程序的内存空间结构

   > 这段空间必须布局为c程序运行所需的空间结构，c程序才能运行

   如果空间没有布局好，进程将无法运行，因此进程空间（c程序的内存空间）也是非常重要的进程环境

   > c的内存结构是由`启动代码`来搭建的
   >
   > > 比如启动代码会把c内存空间的某一部分空间，构建为“栈”，也就是说以“栈”的方式来管理这片内存

c程序代码在内存上运行起来后，它就是一个进程，所以程序代码在内存上所占用的空间，也别称为进程空间

































